"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookError = exports.InvalidSignatureError = exports.InternalServerError = exports.TooManyRequestError = exports.NotFoundError = exports.ForbiddenError = exports.UnauthorizedError = exports.BadRequestError = exports.ConnectionTimeoutError = exports.ConnectionError = exports.UserAbortError = exports.APIError = exports.PayOSError = void 0;
class PayOSError extends Error {
}
exports.PayOSError = PayOSError;
class APIError extends PayOSError {
    constructor(status, error, message, headers) {
        super(APIError.makeMessage(status, error, message));
        this.status = status;
        this.headers = headers;
        this.error = error;
        const response = error;
        this.code = response?.code;
        this.desc = response?.desc;
        Object.defineProperty(this, 'name', { value: new.target.name });
    }
    static makeMessage(status, error, message) {
        let msg;
        if (error?.code && error?.desc) {
            msg = `${error.desc} (code: ${error.code})`;
        }
        else {
            msg =
                error?.message ?
                    typeof error.message === 'string' ?
                        error.message
                        : JSON.stringify(error.message)
                    : error ? JSON.stringify(error)
                        : message;
        }
        if (status && msg) {
            return `HTTP ${status}, ${msg}`;
        }
        if (status) {
            return `HTTP ${status}`;
        }
        if (msg) {
            return `${msg}`;
        }
        return 'No status code or body';
    }
    static generateError(status, errorResponse, message, headers) {
        if (!status || !headers) {
            return new ConnectionError(message);
        }
        const code = errorResponse?.['code'];
        const desc = errorResponse?.['desc'];
        const error = errorResponse?.['error'] ?? { code, desc };
        switch (status) {
            case 400:
                return new BadRequestError(status, error, message, headers);
            case 401:
                return new UnauthorizedError(status, error, message, headers);
            case 403:
                return new ForbiddenError(status, headers, message, headers);
            case 404:
                return new NotFoundError(status, error, message, headers);
            case 429:
                return new TooManyRequestError(status, error, message, headers);
            default:
                return new APIError(status, error, message, headers);
        }
    }
}
exports.APIError = APIError;
class UserAbortError extends APIError {
    constructor(message) {
        super(undefined, undefined, message || 'Request was abort', undefined);
    }
}
exports.UserAbortError = UserAbortError;
class ConnectionError extends APIError {
    constructor(message) {
        super(undefined, undefined, message || 'Connection error.', undefined);
    }
}
exports.ConnectionError = ConnectionError;
class ConnectionTimeoutError extends APIError {
    constructor(message) {
        super(undefined, undefined, message || 'Request timed out.', undefined);
    }
}
exports.ConnectionTimeoutError = ConnectionTimeoutError;
class BadRequestError extends APIError {
}
exports.BadRequestError = BadRequestError;
class UnauthorizedError extends APIError {
}
exports.UnauthorizedError = UnauthorizedError;
class ForbiddenError extends APIError {
}
exports.ForbiddenError = ForbiddenError;
class NotFoundError extends APIError {
}
exports.NotFoundError = NotFoundError;
class TooManyRequestError extends APIError {
}
exports.TooManyRequestError = TooManyRequestError;
class InternalServerError extends APIError {
}
exports.InternalServerError = InternalServerError;
class InvalidSignatureError extends PayOSError {
    constructor(message) {
        super(message);
    }
}
exports.InvalidSignatureError = InvalidSignatureError;
class WebhookError extends PayOSError {
    constructor(messages) {
        super(messages);
    }
}
exports.WebhookError = WebhookError;
