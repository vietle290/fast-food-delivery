"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericPage = exports.Page = void 0;
/**
 * Abstract base class for paginated API responses.
 * Provides both async iteration and manual pagination methods.
 */
class Page {
    constructor(client, data, options) {
        this._client = client;
        this._options = options;
        if (data) {
            this._pagination = data.pagination;
            // Get the first array property from data (could be 'payouts', 'items', etc.)
            const dataKeys = Object.keys(data).filter((key) => key !== 'pagination');
            this._data = dataKeys.length > 0 ? data[dataKeys[0]] : [];
        }
        else {
            this._data = [];
            this._pagination = {
                limit: 0,
                offset: 0,
                total: 0,
                count: 0,
                hasMore: false,
            };
        }
    }
    /**
     * The items in the current page
     */
    get data() {
        return this._data;
    }
    /**
     * Pagination information for the current page
     */
    get pagination() {
        return this._pagination;
    }
    /**
     * Check if there are more pages available
     */
    hasNextPage() {
        return this._pagination.hasMore;
    }
    /**
     * Get the next page of results
     */
    async getNextPage() {
        if (!this.hasNextPage()) {
            throw new Error('No more pages available');
        }
        const nextOffset = this._pagination.offset + this._pagination.count;
        const nextOptions = {
            ...this._options,
            query: {
                ...this._options.query,
                offset: nextOffset,
                limit: this._pagination.limit,
            },
        };
        const response = await this._client.request(nextOptions);
        return this.createPageInstance(this._client, response, nextOptions);
    }
    /**
     * Check if there are previous pages available
     */
    hasPreviousPage() {
        return this._pagination.offset > 0;
    }
    /**
     * Get the previous page of results
     */
    async getPreviousPage() {
        if (!this.hasPreviousPage()) {
            throw new Error('No previous pages available');
        }
        const prevOffset = Math.max(0, this._pagination.offset - this._pagination.limit);
        const prevOptions = {
            ...this._options,
            query: {
                ...this._options.query,
                offset: prevOffset,
                limit: this._pagination.limit,
            },
        };
        const response = await this._client.request(prevOptions);
        return this.createPageInstance(this._client, response, prevOptions);
    }
    /**
     * Async iterator implementation for automatic pagination
     */
    async *[Symbol.asyncIterator]() {
        const iterate = async function* (page) {
            for (const item of page.data) {
                yield item;
            }
            // If there are more pages, recurse to next page
            if (page.hasNextPage()) {
                const next = await page.getNextPage();
                for await (const item of iterate(next)) {
                    yield item;
                }
            }
        };
        for await (const item of iterate(this)) {
            yield item;
        }
    }
    /**
     * Collect all items from all pages into an array
     */
    async toArray() {
        const items = [];
        for await (const item of this) {
            items.push(item);
        }
        return items;
    }
}
exports.Page = Page;
/**
 * Generic paginated response class that can be used for any item type
 */
class GenericPage extends Page {
    createPageInstance(client, data, options) {
        return new GenericPage(client, data, options);
    }
}
exports.GenericPage = GenericPage;
