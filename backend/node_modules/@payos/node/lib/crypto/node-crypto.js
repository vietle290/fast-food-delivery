"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCryptoProvider = void 0;
const crypto_1 = require("crypto");
const sort_obj_by_key_1 = require("../utils/sort-obj-by-key");
const convert_obj_to_query_str_1 = __importDefault(require("../utils/convert-obj-to-query-str"));
/**
 * Node.js crypto implementation using the built-in crypto module
 */
class NodeCryptoProvider {
    /**
     * Generates a SHA-256 HMAC signature from an object by:
     * - Sorting the object's keys
     * - Converting the sorted object to a query string
     * - Creating a HMAC signature using the provided key
     */
    async createSignatureFromObj(data, key) {
        if (!data || !key.length) {
            return null;
        }
        const sortedDataByKey = (0, sort_obj_by_key_1.sortObjDataByKey)(data);
        const dataQueryStr = (0, convert_obj_to_query_str_1.default)(sortedDataByKey);
        const dataToSignature = (0, crypto_1.createHmac)('sha256', key).update(dataQueryStr).digest('hex');
        return dataToSignature;
    }
    /**
     * Generates a SHA-256 HMAC signature for a payment request using specific fields:
     * - amount, cancelUrl, description, orderCode, returnUrl
     * - Concatenates these fields into a query string and signs it with the provided key
     */
    async createSignatureOfPaymentRequest(data, key) {
        if (!data || !key.length) {
            return null;
        }
        const { amount, cancelUrl, description, orderCode, returnUrl } = data;
        const dataStr = `amount=${amount}&cancelUrl=${cancelUrl}&description=${description}&orderCode=${orderCode}&returnUrl=${returnUrl}`;
        const dataToSignature = (0, crypto_1.createHmac)('sha256', key).update(dataStr).digest('hex');
        return dataToSignature;
    }
    /**
     * Create HMAC signature from JSON data with query string format
     */
    async createSignature(secretKey, jsonData, options = {}) {
        const { encodeUri = true, sortArrays = false, algorithm = 'sha256' } = options;
        const sortedData = (0, sort_obj_by_key_1.deepSortObj)(jsonData, sortArrays);
        const queryString = Object.keys(sortedData)
            .map((key) => {
            let value = sortedData[key];
            // Handle arrays by JSON stringify them
            if (Array.isArray(value)) {
                value = JSON.stringify(value);
            }
            // Handle nested objects
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                value = JSON.stringify(value);
            }
            // Handle null/undefined values
            if (value === null || value === undefined) {
                value = '';
            }
            // Conditionally URL encode the key and value based on options
            if (encodeUri) {
                return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
            }
            return `${key}=${value}`;
        })
            .join('&');
        const hmac = (0, crypto_1.createHmac)(algorithm, secretKey).update(queryString).digest('hex');
        return hmac;
    }
    /**
     * Generate a random UUIDv4 string using Node.js crypto.randomUUID
     */
    createUuidv4() {
        return (0, crypto_1.randomUUID)();
    }
}
exports.NodeCryptoProvider = NodeCryptoProvider;
