import { Logger, LogLevel } from './utils/log';
import { CryptoProvider } from './crypto';
import { PaymentRequests, Payouts, PayoutsAccount, Webhooks } from './resources';
import { FileDownloadResponse } from './core/api-response';
import * as Errors from './core/error';
import { FinalRequestOptions, HeadersLike, RequestOptions } from './core/request-options';
export interface PayOSOptions {
    /**
     * Defaults to process.env['PAYOS_CLIENT_ID'].
     */
    clientId?: string;
    /**
     * Defaults to process.env['PAYOS_API_KEY'].
     */
    apiKey?: string;
    /**
     * Defaults to process.env['PAYOS_CHECKSUM_KEY'].
     */
    checksumKey?: string;
    /**
     * Defaults to process.env['PAYOS_PARTNER_CODE'].
     */
    partnerCode?: string | null | undefined;
    /**
     * Override the default base URL for the API.
     *
     * Defaults to process.env['PAYOS_BASE_URL'].
     */
    baseURL?: string | null | undefined;
    /**
     * Set the logger.
     *
     * Defaults to globalThis.console.
     */
    logger?: Logger | null | undefined;
    /**
     * Set the log level.
     *
     * Defaults to process.env['PAYOS_LOG'] or 'warn' if is isn't set.
     */
    logLevel?: LogLevel | null | undefined;
    /**
     * Additional `RequestInit` options to be passed to `fetch` calls.
     * Properties will be overridden by per-request `fetchOptions`.
     */
    fetchOptions?: RequestInit | null | undefined;
    /**
     * A custom fetch implementation to use for HTTP requests.
     * If not provided, we expected that `fetch` is defined globally.
     */
    fetch?: (input: string | URL | Request, init?: RequestInit) => Promise<Response>;
    /**
     * The maximum amount of time (milliseconds) that the client should wait for a response
     * from the server before timing out a single request.
     *
     * @unit milliseconds
     */
    timeout?: number | null | undefined;
    /**
     * The maximums number of times that the client will retry a request.
     *
     * @default 2
     */
    maxRetries?: number | null | undefined;
}
/**
 * API client for interacting with payOS Merchant API.
 */
export declare class PayOS {
    apiKey: string;
    clientId: string;
    checksumKey: string;
    partnerCode?: string | null | undefined;
    baseURL: string;
    logger?: Logger | null | undefined;
    logLevel?: LogLevel | null | undefined;
    fetchOptions: RequestInit;
    private fetch;
    timeout: number;
    maxRetries: number;
    crypto: CryptoProvider;
    /**
     * Create a new PayOS API client instance.
     *
     * @param {PayOSOptions} [options] - Client configuration options.
     * @param {string|undefined} [opts.clientId=process.env['PAYOS_CLIENT_ID'] ?? undefined] - Client ID.
     * @param {string|undefined} [opts.apiKey=process.env['PAYOS_API_KEY'] ?? undefined] - API key.
     * @param {string|undefined} [opts.checksumKey=process.env['PAYOS_CHECKSUM_KEY'] ?? undefined] - Checksum key.
     * @param {string|undefined} [opts.partnerCode=process.env['PAYOS_PARTNER_CODE'] ?? undefined] - Partner code.
     * @param {string} [opts.baseURL=process.env['PAYOS_BASE_URL'] ?? https://api-merchant.payos.vn] - Override the default base URL for the API.
     * @param {number} [opts.timeouts=60_000] - The maximum amount of time (in milliseconds) the client will be wait for a response before timing out.
     * @param {RequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
     * @param {Fetch} [opts.fetch] - Specific custom `fetch` function implement.
     * @param {number} [opts.maxRetries=3] - The maximum number of times the client will retry a request.
     */
    constructor({ clientId, apiKey, checksumKey, partnerCode, baseURL, ...opts }?: PayOSOptions);
    private getUserAgent;
    protected buildHeaders(additionalHeaders?: HeadersLike): Record<string, any>;
    protected buildUrl(endpoint: string, queries?: Record<string, any>): string;
    protected buildBody<T = any>(body: T): any;
    protected makeStatusError(status: number, error: object, message: string | undefined, headers: Headers): Errors.APIError<number | undefined, Headers | undefined, object | undefined>;
    private shouldRetryRequest;
    private sleep;
    private executeRequest;
    private retryRequest;
    private executeFileDownload;
    private retryDownloadFile;
    get<TResponse = any, TRequest = any>(path: string, options?: RequestOptions<TRequest>): Promise<TResponse>;
    post<TResponse = any, TRequest = any>(path: string, options?: RequestOptions<TRequest>): Promise<TResponse>;
    patch<TResponse = any, TRequest = any>(path: string, options?: RequestOptions<TRequest>): Promise<TResponse>;
    put<TResponse = any, TRequest = any>(path: string, options?: RequestOptions<TRequest>): Promise<TResponse>;
    delete<TResponse = any, TRequest = any>(path: string, options?: RequestOptions<TRequest>): Promise<TResponse>;
    private methodRequest;
    request<TResponse = any, TRequest = any>(options: FinalRequestOptions<TRequest>, remainingRetries?: number | undefined): Promise<TResponse>;
    downloadFile<TRequest = any>(options: Omit<FinalRequestOptions<TRequest>, 'responseType' | 'signatureOpts'>, remainingRetries?: number | undefined): Promise<FileDownloadResponse>;
    static PayOS: typeof PayOS;
    static DEFAULT_TIMEOUT: number;
    static MAX_RETRIES: number;
    static PayOSError: typeof Errors.PayOSError;
    static APIError: typeof Errors.APIError;
    static UserAbortError: typeof Errors.UserAbortError;
    static ConnectionError: typeof Errors.ConnectionError;
    static ConnectionTimeoutError: typeof Errors.ConnectionTimeoutError;
    static BadRequestError: typeof Errors.BadRequestError;
    static UnauthorizedError: typeof Errors.UnauthorizedError;
    static ForbiddenError: typeof Errors.ForbiddenError;
    static NotFoundError: typeof Errors.NotFoundError;
    static TooManyRequest: typeof Errors.TooManyRequestError;
    static InternalServerError: typeof Errors.InternalServerError;
    static InvalidSignatureError: typeof Errors.InvalidSignatureError;
    static WebhookError: typeof Errors.WebhookError;
    webhooks: Webhooks;
    paymentRequests: PaymentRequests;
    payouts: Payouts;
    payoutsAccount: PayoutsAccount;
}
