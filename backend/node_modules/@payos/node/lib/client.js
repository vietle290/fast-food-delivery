"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayOS = void 0;
const env_1 = require("./utils/env");
const log_1 = require("./utils/log");
const detect_platform_1 = require("./utils/detect-platform");
const crypto_1 = require("./crypto");
const resources_1 = require("./resources");
const Errors = __importStar(require("./core/error"));
const error_1 = require("./utils/error");
const values_1 = require("./utils/values");
const version_1 = require("./version");
const BASE_URL = 'https://api-merchant.payos.vn';
/**
 * API client for interacting with payOS Merchant API.
 */
class PayOS {
    /**
     * Create a new PayOS API client instance.
     *
     * @param {PayOSOptions} [options] - Client configuration options.
     * @param {string|undefined} [opts.clientId=process.env['PAYOS_CLIENT_ID'] ?? undefined] - Client ID.
     * @param {string|undefined} [opts.apiKey=process.env['PAYOS_API_KEY'] ?? undefined] - API key.
     * @param {string|undefined} [opts.checksumKey=process.env['PAYOS_CHECKSUM_KEY'] ?? undefined] - Checksum key.
     * @param {string|undefined} [opts.partnerCode=process.env['PAYOS_PARTNER_CODE'] ?? undefined] - Partner code.
     * @param {string} [opts.baseURL=process.env['PAYOS_BASE_URL'] ?? https://api-merchant.payos.vn] - Override the default base URL for the API.
     * @param {number} [opts.timeouts=60_000] - The maximum amount of time (in milliseconds) the client will be wait for a response before timing out.
     * @param {RequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
     * @param {Fetch} [opts.fetch] - Specific custom `fetch` function implement.
     * @param {number} [opts.maxRetries=3] - The maximum number of times the client will retry a request.
     */
    constructor({ clientId = (0, env_1.readEnv)('PAYOS_CLIENT_ID'), apiKey = (0, env_1.readEnv)('PAYOS_API_KEY'), checksumKey = (0, env_1.readEnv)('PAYOS_CHECKSUM_KEY'), partnerCode = (0, env_1.readEnv)('PAYOS_PARTNER_CODE'), baseURL = (0, env_1.readEnv)('PAYOS_BASE_URL'), ...opts } = {}) {
        this.webhooks = new resources_1.Webhooks(this);
        this.paymentRequests = new resources_1.PaymentRequests(this);
        this.payouts = new resources_1.Payouts(this);
        this.payoutsAccount = new resources_1.PayoutsAccount(this);
        if (clientId === undefined) {
            throw new Errors.PayOSError('The PAYOS_CLIENT_ID environment variable is missing or empty; either provide it, or instantiate the PayOS client with a clientId option.');
        }
        this.clientId = clientId;
        if (apiKey === undefined) {
            throw new Errors.PayOSError('The PAYOS_API_KEY environment variable is missing or empty; either provide it, or instantiate the PayOS client with a apiKey option.');
        }
        this.apiKey = apiKey;
        if (checksumKey === undefined) {
            throw new Errors.PayOSError('The PAYOS_CHECKSUM_KEY environment variable is missing or empty; either provide it, or instantiate the PayOS client with a checksumKey option.');
        }
        this.checksumKey = checksumKey;
        this.partnerCode = partnerCode;
        this.baseURL = baseURL ?? BASE_URL;
        this.logger = opts.logger || {
            error: console.error.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console),
            debug: console.debug.bind(console),
        };
        const defaultLogLevel = 'warn';
        this.logLevel = defaultLogLevel;
        this.logLevel =
            (0, log_1.parseLogLevel)(opts.logLevel, 'PayOSOptions.logLevel', this) ??
                (0, log_1.parseLogLevel)((0, env_1.readEnv)('PAYOS_LOG'), "process.env['PAYOS_LOG']", this) ??
                defaultLogLevel;
        this.timeout = opts.timeout ?? _a.DEFAULT_TIMEOUT;
        this.maxRetries = opts.maxRetries ?? _a.MAX_RETRIES;
        this.crypto = (0, crypto_1.createCryptoProvider)();
        this.fetchOptions = opts.fetchOptions ?? {};
        this.fetch = opts.fetch ?? (0, detect_platform_1.getDefaultFetch)();
    }
    getUserAgent() {
        return `${this.constructor.name}/JS ${version_1.VERSION}`;
    }
    buildHeaders(additionalHeaders) {
        const headers = {
            'x-client-id': this.clientId,
            'x-api-key': this.apiKey,
            'Content-Type': 'application/json',
            'User-Agent': this.getUserAgent(),
        };
        if (this.partnerCode) {
            headers['x-partner-code'] = this.partnerCode;
        }
        if (additionalHeaders) {
            Object.assign(headers, additionalHeaders);
        }
        return headers;
    }
    buildUrl(endpoint, queries) {
        const url = new URL(endpoint, this.baseURL);
        if (queries && Object.keys(queries).length > 0) {
            const params = new URLSearchParams();
            Object.keys(queries).forEach((key) => {
                const val = queries[key];
                if (val === undefined) {
                    return;
                }
                if (val === null) {
                    params.append(key, '');
                    return;
                }
                if (Array.isArray(val) || typeof val === 'object') {
                    params.append(key, JSON.stringify(val));
                }
                else {
                    params.append(key, String(val));
                }
            });
            // Append params to url
            const qs = params.toString();
            if (qs) {
                url.search = qs;
            }
        }
        return url.toString();
    }
    buildBody(body) {
        if (body &&
            typeof body === 'object' &&
            !(body instanceof globalThis.ReadableStream) &&
            !(body instanceof FormData) &&
            !(body instanceof ArrayBuffer) &&
            !(body instanceof Uint8Array) &&
            typeof body !== 'string') {
            return JSON.stringify(body);
        }
        return body;
    }
    makeStatusError(status, error, message, headers) {
        return Errors.APIError.generateError(status, error, message, headers);
    }
    async shouldRetryRequest(response) {
        if (response.status === 408) {
            return true;
        }
        if (response.status === 429) {
            return true;
        }
        if (response.status >= 500) {
            return true;
        }
        return false;
    }
    async sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    async executeRequest(options, retriesRemaining, retryOfRequestLogID) {
        if (retriesRemaining === undefined) {
            retriesRemaining = options.maxRetries ?? this.maxRetries;
        }
        if ('timeout' in options) {
            (0, values_1.validatePositiveInteger)('timeout', options.timeout);
        }
        const { path, method = 'GET', body: requestData, query, headers, signatureOpts } = options;
        const logger = (0, log_1.loggerFor)(this);
        const url = this.buildUrl(path, query);
        // Handle request signing if required
        let body = requestData;
        let requestHeaders = headers;
        // Build signature
        if (signatureOpts?.request && body) {
            let signature = null;
            switch (signatureOpts.request) {
                case 'create-payment-link':
                    signature = await this.crypto.createSignatureOfPaymentRequest(body, this.checksumKey);
                    if (!signature) {
                        throw new Errors.InvalidSignatureError('Failed to create payment signature');
                    }
                    body = { ...body, signature };
                    break;
                case 'body':
                    signature = await this.crypto.createSignatureFromObj(body, this.checksumKey);
                    if (!signature) {
                        throw new Errors.InvalidSignatureError('Failed to create body signature');
                    }
                    body = { ...body, signature };
                    break;
                case 'header':
                    signature = await this.crypto.createSignature(this.checksumKey, body);
                    requestHeaders =
                        requestHeaders ? { ...requestHeaders, 'x-signature': signature } : { 'x-signature': signature };
                    break;
                default:
                    throw new Errors.InvalidSignatureError('Invalid signature request type');
            }
        }
        const buildedHeaders = this.buildHeaders(requestHeaders);
        /** Not an API request ID, just for correlating local log entries. */
        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');
        const retryLogStr = retryOfRequestLogID ? `, retry of: ${retryOfRequestLogID}` : '';
        const startTime = Date.now();
        const timeoutSignal = AbortSignal.timeout(options.timeout ?? this.timeout);
        const combinedSignal = options.signal ? AbortSignal.any([timeoutSignal, options.signal]) : timeoutSignal;
        const serializedBody = this.buildBody(body);
        const fetchConfig = {
            method,
            headers: buildedHeaders,
            signal: combinedSignal,
            ...(globalThis.ReadableStream &&
                body instanceof globalThis.ReadableStream && { duplex: 'half' }),
            ...(serializedBody && { body: serializedBody }),
            ...(this.fetchOptions ?? {}),
            ...(options.fetchOptions ?? {}),
        };
        logger.debug(`[${requestLogID}] sending request`, (0, log_1.formatRequestDetail)({
            url,
            method,
            headers: buildedHeaders,
            options,
            retryOf: retryOfRequestLogID,
            body: serializedBody,
        }));
        if (fetchConfig.signal?.aborted) {
            if (timeoutSignal.aborted) {
                throw new Errors.ConnectionTimeoutError();
            }
            throw new Errors.UserAbortError();
        }
        const response = await this.fetch(url, fetchConfig).catch(error_1.castToError);
        const headersTime = Date.now();
        if (response instanceof Error) {
            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
            if (fetchConfig.signal?.aborted && !timeoutSignal.aborted) {
                throw new Errors.UserAbortError();
            }
            const isTimeout = timeoutSignal.aborted;
            if (retriesRemaining) {
                logger.info(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - ${retryMessage}`);
                logger.debug(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - ${retryMessage}`, (0, log_1.formatRequestDetail)({
                    url,
                    message: response.message,
                    durationMs: headersTime - startTime,
                    retryOf: retryOfRequestLogID,
                }));
                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
            }
            logger.info(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - error; no more retries left.`);
            logger.debug(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - error; no more retries left.`, (0, log_1.formatRequestDetail)({
                url,
                durationMs: headersTime - startTime,
                message: response.message,
                retryOf: retryOfRequestLogID,
            }));
            if (isTimeout) {
                throw new Errors.ConnectionTimeoutError();
            }
            throw new Errors.ConnectionError();
        }
        const responseInfo = `[${requestLogID}${retryLogStr}] ${method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
            const shouldRetry = await this.shouldRetryRequest(response);
            if (retriesRemaining && shouldRetry) {
                const retryMsg = `retrying, ${retriesRemaining} attempts remaining`;
                logger.info(`${responseInfo} - ${retryMsg}`);
                logger.debug(`[${requestLogID}] response error (${retryMsg})`, (0, log_1.formatRequestDetail)({
                    url: response.url,
                    status: response.status,
                    headers: response.headers,
                    durationMs: headersTime - startTime,
                    retryOf: retryOfRequestLogID,
                }));
                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
            }
            const retryMessage = shouldRetry ? 'error; no more retries left' : 'error: cannot retry';
            logger.info(`${responseInfo} - ${retryMessage}`);
            const errText = await response.text().catch((err) => (0, error_1.castToError)(err).message);
            const errJSON = (0, values_1.safeJSON)(errText);
            const errMessage = errJSON ? undefined : errText;
            logger.debug(`[${requestLogID}] response error (${retryMessage})`, (0, log_1.formatRequestDetail)({
                url: response.url,
                status: response.status,
                headers: response.headers,
                message: errMessage,
                durationMs: Date.now() - startTime,
                retryOf: retryOfRequestLogID,
            }));
            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
            throw err;
        }
        const rawJson = await response.json();
        const { data, code, desc, signature } = rawJson;
        if (code !== '00' || !data) {
            throw this.makeStatusError(response.status, { data, code, desc, signature }, desc, response.headers);
        }
        // Build response signature
        if (signatureOpts?.response) {
            const resSignature = signatureOpts.response === 'body' ? signature : response.headers.get('x-signature');
            if (resSignature && data) {
                const signedSignature = signatureOpts.response === 'body' ?
                    await this.crypto.createSignatureFromObj(data, this.checksumKey)
                    : await this.crypto.createSignature(this.checksumKey, data);
                if (resSignature !== signedSignature) {
                    throw new Errors.InvalidSignatureError('Data integrity check failed');
                }
            }
        }
        return data;
    }
    async retryRequest(options, retriesRemaining, retryOfRequestLogID, responseHeaders) {
        let timeoutMs;
        const retryAfter = responseHeaders?.get('retry-after');
        const rateLimitReset = responseHeaders?.get('x-ratelimit-reset');
        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
        if (retryAfter) {
            const timeoutSecond = parseFloat(retryAfter);
            if (!Number.isNaN(timeoutSecond)) {
                timeoutMs = timeoutSecond * 1000;
            }
            else {
                timeoutMs = Date.parse(retryAfter) - Date.now();
            }
        }
        if (rateLimitReset) {
            const timeoutSecond = parseFloat(rateLimitReset);
            if (!Number.isNaN(timeoutSecond)) {
                timeoutMs = timeoutSecond * 1000 - Date.now();
            }
        }
        if (!(timeoutMs && timeoutMs >= 0 && timeoutMs < 60 * 1000)) {
            const initRetryDelay = 0.5;
            const maxRetryDelay = 10.0;
            const numRetries = options.maxRetries ?? this.maxRetries - retriesRemaining;
            const sleepSeconds = Math.min(initRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
            // Apply some jitter to avoid thunder herd
            const jitter = 1 - Math.random() * 0.25;
            timeoutMs = sleepSeconds * jitter * 1000;
        }
        await this.sleep(timeoutMs);
        return this.executeRequest(options, retriesRemaining - 1, retryOfRequestLogID);
    }
    async executeFileDownload(options, retriesRemaining, retryOfRequestLogID) {
        if (retriesRemaining === undefined) {
            retriesRemaining = options.maxRetries ?? this.maxRetries;
        }
        if ('timeout' in options) {
            (0, values_1.validatePositiveInteger)('timeout', options.timeout);
        }
        const { path, method = 'GET', body, query, headers } = options;
        const logger = (0, log_1.loggerFor)(this);
        const url = this.buildUrl(path, query);
        const buildedHeaders = this.buildHeaders(headers);
        /** Not an API request ID, just for correlating local log entries. */
        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');
        const retryLogStr = retryOfRequestLogID ? `, retry of: ${retryOfRequestLogID}` : '';
        const startTime = Date.now();
        const timeoutSignal = AbortSignal.timeout(options.timeout ?? this.timeout);
        const combinedSignal = options.signal ? AbortSignal.any([timeoutSignal, options.signal]) : timeoutSignal;
        const serializedBody = this.buildBody(body);
        const fetchConfig = {
            method,
            headers: buildedHeaders,
            signal: combinedSignal,
            ...(globalThis.ReadableStream &&
                body instanceof globalThis.ReadableStream && { duplex: 'half' }),
            ...(serializedBody && { body: serializedBody }),
            ...(this.fetchOptions ?? {}),
            ...(options.fetchOptions ?? {}),
        };
        logger.debug(`[${requestLogID}${retryLogStr}] sending file download request`, (0, log_1.formatRequestDetail)({
            url,
            method,
            headers: buildedHeaders,
            options,
            retryOf: retryOfRequestLogID,
            body: serializedBody,
        }));
        if (fetchConfig.signal?.aborted) {
            if (timeoutSignal.aborted) {
                throw new Errors.ConnectionTimeoutError();
            }
            throw new Errors.UserAbortError();
        }
        const response = await this.fetch(url, fetchConfig).catch(error_1.castToError);
        const headersTime = Date.now();
        if (response instanceof Error) {
            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
            if (fetchConfig.signal?.aborted && !timeoutSignal.aborted) {
                throw new Errors.UserAbortError();
            }
            const isTimeout = timeoutSignal.aborted;
            if (retriesRemaining) {
                logger.info(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - ${retryMessage}`);
                logger.debug(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - ${retryMessage}`, (0, log_1.formatRequestDetail)({
                    url,
                    durationMs: headersTime - startTime,
                    message: response.message,
                    retryOf: retryOfRequestLogID,
                }));
                return this.retryDownloadFile(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
            }
            logger.info(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - error; no more retries left.`);
            logger.debug(`[${requestLogID}] connection ${isTimeout ? 'timeout' : 'failed'} - error; no more retries left.`, (0, log_1.formatRequestDetail)({
                url,
                durationMs: headersTime - startTime,
                message: response.message,
                retryOf: retryOfRequestLogID,
            }));
            if (isTimeout) {
                throw new Errors.ConnectionTimeoutError();
            }
            throw new Errors.ConnectionError();
        }
        const responseInfo = `[${requestLogID}] ${method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
            const shouldRetry = await this.shouldRetryRequest(response);
            if (retriesRemaining && shouldRetry) {
                const retryMsg = `retrying, ${retriesRemaining} attempts remaining`;
                logger.info(`${responseInfo} - ${retryMsg}`);
                logger.debug(`[${requestLogID}] response error (${retryMsg})`, (0, log_1.formatRequestDetail)({
                    url: response.url,
                    status: response.status,
                    headers: response.headers,
                    durationMs: headersTime - startTime,
                    retryOf: retryOfRequestLogID,
                }));
                return this.retryDownloadFile(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
            }
            const retryMessage = shouldRetry ? 'error; no more retries left' : 'error: cannot retry';
            logger.info(`${responseInfo} - ${retryMessage}`);
            const errText = await response.text().catch((err) => (0, error_1.castToError)(err).message);
            const errJSON = (0, values_1.safeJSON)(errText);
            const errMessage = errJSON ? undefined : errText;
            logger.debug(`[${requestLogID}] response error (${retryMessage})`, (0, log_1.formatRequestDetail)({
                url: response.url,
                status: response.status,
                headers: response.headers,
                message: errMessage,
                durationMs: Date.now() - startTime,
                retryOf: retryOfRequestLogID,
            }));
            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
            throw err;
        }
        if (response.headers.get('content-type')?.includes('application/json')) {
            const rawJson = await response.json();
            const { code, desc } = rawJson;
            throw this.makeStatusError(response.status, { code, desc }, desc, response.headers);
        }
        const arrayBuffer = await response.arrayBuffer();
        const contentType = response.headers.get('content-type') || 'application/octet-stream';
        const contentDisposition = response.headers.get('content-disposition');
        const contentLength = response.headers.get('content-length');
        let filename;
        if (contentDisposition) {
            const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
            if (filenameMatch) {
                filename = filenameMatch[1].replace(/['"]/g, '');
            }
        }
        return {
            filename,
            contentType,
            size: contentLength ? parseInt(contentLength, 10) : undefined,
            data: arrayBuffer,
        };
    }
    async retryDownloadFile(options, retriesRemaining, retryOfRequestLogID, responseHeaders) {
        let timeoutMs;
        const retryAfter = responseHeaders?.get('retry-after');
        const rateLimitReset = responseHeaders?.get('x-ratelimit-reset');
        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
        if (retryAfter) {
            const timeoutSecond = parseFloat(retryAfter);
            if (!Number.isNaN(timeoutSecond)) {
                timeoutMs = timeoutSecond * 1000;
            }
            else {
                timeoutMs = Date.parse(retryAfter) - Date.now();
            }
        }
        if (rateLimitReset) {
            const timeoutSecond = parseFloat(rateLimitReset);
            if (!Number.isNaN(timeoutSecond)) {
                timeoutMs = timeoutSecond * 1000;
            }
        }
        if (!(timeoutMs && timeoutMs >= 0 && timeoutMs < 60 * 1000)) {
            const initRetryDelay = 0.5;
            const maxRetryDelay = 10.0;
            const numRetries = options.maxRetries ?? this.maxRetries - retriesRemaining;
            const sleepSeconds = Math.min(initRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
            // Apply some jitter to avoid thunder herd
            const jitter = 1 - Math.random() * 0.25;
            timeoutMs = sleepSeconds * jitter * 1000;
        }
        await this.sleep(timeoutMs);
        return this.executeFileDownload(options, retriesRemaining - 1, retryOfRequestLogID);
    }
    get(path, options) {
        return this.methodRequest('GET', path, options);
    }
    post(path, options) {
        return this.methodRequest('POST', path, options);
    }
    patch(path, options) {
        return this.methodRequest('PATCH', path, options);
    }
    put(path, options) {
        return this.methodRequest('PUT', path, options);
    }
    delete(path, options) {
        return this.methodRequest('DELETE', path, options);
    }
    methodRequest(method, path, options) {
        return this.request({ method, path, ...options });
    }
    async request(options, remainingRetries = undefined) {
        return this.executeRequest(options, remainingRetries);
    }
    async downloadFile(options, remainingRetries = undefined) {
        return this.executeFileDownload(options, remainingRetries);
    }
}
exports.PayOS = PayOS;
_a = PayOS;
PayOS.PayOS = _a;
PayOS.DEFAULT_TIMEOUT = 60000;
PayOS.MAX_RETRIES = 2;
PayOS.PayOSError = Errors.PayOSError;
PayOS.APIError = Errors.APIError;
PayOS.UserAbortError = Errors.UserAbortError;
PayOS.ConnectionError = Errors.ConnectionError;
PayOS.ConnectionTimeoutError = Errors.ConnectionTimeoutError;
PayOS.BadRequestError = Errors.BadRequestError;
PayOS.UnauthorizedError = Errors.UnauthorizedError;
PayOS.ForbiddenError = Errors.ForbiddenError;
PayOS.NotFoundError = Errors.NotFoundError;
PayOS.TooManyRequest = Errors.TooManyRequestError;
PayOS.InternalServerError = Errors.InternalServerError;
PayOS.InvalidSignatureError = Errors.InvalidSignatureError;
PayOS.WebhookError = Errors.WebhookError;
